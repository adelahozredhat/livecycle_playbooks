---
- hosts: all
  connection: local
  gather_facts: false
  vars:
    controller_configuration_projects_async_retries: 120
    controller_configuration_projects_async_delay: 2
    aap_username: "{{ vault_controller_username | default(lookup('env', 'CONTROLLER_USERNAME')) }}"
    aap_password: "{{ vault_controller_password | default(lookup('env', 'CONTROLLER_PASSWORD')) }}"
    aap_hostname: "{{ vault_controller_hostname | default(lookup('env', 'CONTROLLER_HOST')) }}"
    aap_validate_certs: "{{ vault_controller_validate_certs | default(lookup('env', 'CONTROLLER_VERIFY_SSL')) }}"

    controller_projects_aux: "{{controller_projects_vars| from_yaml}}"
    controller_projects: "{{controller_projects_aux.controller_projects| default([])}}"
    controller_templates_aux: "{{controller_templates_vars| from_yaml}}"
    controller_templates: "{{controller_templates_aux.controller_templates| default([])}}"
    is_awx: "{{ awx_job_id is defined }}"
    path_token: "{{ '/api/v2/tokens/' if is_awx else '/api/gateway/v1/tokens/' }}"
    path_controller: "{{ '/api/v2/' if is_awx else '/api/controller/v2/' }}"
    local_path: "/tmp/repository_clone"
  tasks:
    - name: "Setup authentication (block)"
      block:
        - name: "Get the Authentication Token for the future requests"
          ansible.builtin.uri:
            url: "https://{{ aap_hostname }}{{path_token}}"
            user: "{{ aap_username }}"
            password: "{{ aap_password }}"
            method: POST
            force_basic_auth: true
            validate_certs: "{{ aap_validate_certs }}"
            status_code: 201
          register: authtoken_res

        - name: "Set the oauth token to be used since now"
          ansible.builtin.set_fact:
            controller_oauthtoken: "{{ authtoken_res.json.token }}"
            aap_oauthtoken_url: "{{ authtoken_res.json.url }}"
      no_log: "{{ controller_configuration_filetree_read_secure_logging | default('false') }}"
      when: aap_oauthtoken is not defined
      tags:
        - always
      rescue:
        
        - name: Send Vars OutPut
          ansible.builtin.set_stats:
            data: 
              casc_execution_failed: true
              casc_id_execution: "{{awx_job_id }}"

        - name: Errors Checks
          ansible.builtin.fail:
            msg: 
              - "{{ 'Fallo en el proceso de ejecucion del CasC error al conectar con AWX' }}"

      when: awx_webhook_payload.head_commit.message.startswith("[PROMOTE-TO-AWX]")  and (sign_execution_failed is not defined or not sign_execution_faile)

    - name: Bloque principal para ejecutar roles protegidos
      block:
        # === Llamada a Roles usando include_role dentro del block ===

        - name: Ejecutar Rol de Clonado Repositorio
          ansible.builtin.include_role:
            name: clone_repository

        - name: Cargar CasC JobTemplates
          ansible.builtin.include_vars:
            file: "/tmp/repository_clone/casc/dev/controller_job_templates.yaml" 

        - name: Cargar CasC Projects
          ansible.builtin.include_vars:
            file: "/tmp/repository_clone/casc/dev/controller_projects.yaml" 

        - name: Ejecutar Rol de Dispatch
          ansible.builtin.include_role:
            name: infra.controller_configuration.dispatch
        
        - name: Send Vars OutPut
          ansible.builtin.set_stats:
            data: 
              casc_execution_failed: false
            
        # ==========================================================

        - name: Init info controller_projects
          ansible.builtin.set_fact: 
              controller_info_projects: []

        - name: Iterar sobre Proyectos y Buscar ID en AWX
          ansible.builtin.uri:
            url: "https://{{ aap_hostname }}{{path_controller}}projects/?search={{item.name| urlencode}}"
            method: GET
            user: "{{ aap_username }}"
            password: "{{ aap_password }}"
            validate_certs: no
            status_code: 200
            force_basic_auth: yes
            return_content: yes
            # Filtramos por el nombre del proyecto actual
            # AWX usa el filtro 'name__iexact' o 'name'
            # Esto requiere que tu AWX esté accesible y configurado.
          register: project_search_result
          loop: "{{ controller_projects }}"

        - name: Construir la Nueva Lista con Nombre y URL
          ansible.builtin.set_fact:
            controller_info_projects: "{{ controller_info_projects + [new_item] }}"
          vars:
            # Obtenemos el ID del primer resultado de la búsqueda
            # Asume que el proyecto existe y que la búsqueda devuelve al menos un resultado.
            id: "{{ item.json.results[0].id | default(None) }}"
            # Creamos el nuevo elemento a añadir a la lista
            new_item:
              name: "{{ item.json.results[0].name }}"
              project_id: "{{id}}"
              # Generamos la URL usando el ID encontrado
              access_url: "https://{{ aap_hostname }}/#/projects/{{ id }}"
          loop: "{{ project_search_result.results }}"

        - name: Init info controller_templates
          ansible.builtin.set_fact: 
              controller_info_templates: []

        - name: Iterar sobre Templates y Buscar ID en AWX
          ansible.builtin.uri:
            url: "https://{{ aap_hostname }}{{path_controller}}job_templates/?search={{item.name| urlencode}}"
            method: GET
            user: "{{ aap_username }}"
            password: "{{ aap_password }}"
            validate_certs: no
            status_code: 200
            force_basic_auth: yes
            return_content: yes
            # Filtramos por el nombre del proyecto actual
            # AWX usa el filtro 'name__iexact' o 'name'
            # Esto requiere que tu AWX esté accesible y configurado.
          register: jobteamplate_search_result
          loop: "{{ controller_templates }}"

        - name: Construir la Nueva Lista con Nombre y URL
          ansible.builtin.set_fact:
            controller_info_templates: "{{ controller_info_templates + [new_item] }}"
          vars:
            # Obtenemos el ID del primer resultado de la búsqueda
            # Asume que el proyecto existe y que la búsqueda devuelve al menos un resultado.
            id: "{{ item.json.results[0].id | default(None) }}"
            # Creamos el nuevo elemento a añadir a la lista
            new_item:
              name: "{{ item.json.results[0].name }}"
              job_template_id: "{{ id }}"
              # Generamos la URL usando el ID encontrado
              access_url: "https://{{ aap_hostname }}/#/job_templates/{{ id }}"
              launch_url: "https://{{ aap_hostname }}/api/v2/job_templates/{{ id }}/launch/"
          loop: "{{ jobteamplate_search_result.results }}"
          # El `loop` aquí debe coincidir con el número de resultados de la tarea anterior
        
        - name: Send Vars OutPut
          ansible.builtin.set_stats:
            data: 
              controller_info_projects: "{{controller_info_projects }}"
              controller_info_templates: "{{controller_info_templates}}"

        - name: "Delete the Authentication Token used"
          ansible.builtin.uri:
            url: "https://{{ aap_hostname }}{{aap_oauthtoken_url }}"
            user: "{{ aap_username }}"
            password: "{{ aap_password }}"
            method: DELETE
            force_basic_auth: true
            validate_certs: "{{ aap_validate_certs }}"
            status_code: 204
          when: aap_oauthtoken_url is defined

      rescue:
        
        - name: Send Vars OutPut
          ansible.builtin.set_stats:
            data: 
              casc_execution_failed: true
              casc_id_execution: "{{awx_job_id }}"

        - name: Errors Checks
          ansible.builtin.fail:
            msg: 
              - "{{ 'Fallo en el proceso de ejecucion del CasC' }}"

      when: awx_webhook_payload.head_commit.message.startswith("[PROMOTE-TO-AWX]") and (sign_execution_failed is not defined or not sign_execution_faile)
